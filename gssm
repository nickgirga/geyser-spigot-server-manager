#!/usr/bin/python3.10
# gssm
# Version 1.0
# Nicholas Girga
# Released under MIT license with ABSOLUTELY NO WARRANTY

# This program helps maintain a Minecraft Spigot server that utilizes Geyser

# TODO:
# - download files to temporary directory, so they don't overwrite the originals until they are verified
# - implement world manager
# - implement player manager
# - implement launch option (for both the CLI menu and the direct commands) to use a custom Java version; e.g. "--java /usr/lib/jvm/java-11-openjdk/bin/java"
# - implement GitLab plugin downloader
# - implement self-updater

""" imports """
import datetime, os, subprocess, sys, urllib

""" constants """
APP_VERSION = "1.0"

MD5_LENGTH = 32

# directories
GSSM_DIRECTORY = os.path.expanduser("~") + "/.local/share/gssm" # remove trailing forward/back slashes
GSSM_CONFIG_DIRECTORY = os.path.expanduser("~") + "/.config/gssm" # remove trailing forward/back slashes

# config files
PLUGIN_REPOS_FILE = GSSM_CONFIG_DIRECTORY + "/plugin_repos"

# log files
UPDATE_SERVER_LOG_FILE = GSSM_DIRECTORY + "/logs/update_server.log"
UPDATE_PLUGINS_LOG_FILE = GSSM_DIRECTORY + "/logs/update_plugins.log"
RUN_SERVER_LOG_FILE = GSSM_DIRECTORY + "/logs/run_server.log"

# BuildTools.jar log file
BUILD_TOOLS_LOG_FILE = os.getcwd() + "/BuildTools.log.txt"

# added to the end of a Jenkins URL to see the web page with the md5 on it
JENKINS_FINGERPRINT_SUFFIX = "/*fingerprint*/"
# what to save the Jenkins fingerprint webpage as
JENKINS_FINGERPRINT_FILE = ".jenkins_fingerprint.html"

# this tool is responsible for building the spigot server executable; see here for more info: https://www.spigotmc.org/wiki/buildtools/#what-is-it
BUILD_TOOLS_REMOTE_LOCATION = "https://hub.spigotmc.org/jenkins/job/BuildTools/lastSuccessfulBuild/artifact/target/BuildTools.jar"
BUILD_TOOLS_FILE = "BuildTools.jar"

PLUGIN_DIRECTORY = "./plugins"
# this plugin is responsible for allowing Bedrock players to connect to Java servers; see here for more info: https://github.com/GeyserMC/Geyser
GEYSER_REMOTE_LOCATION = "https://ci.opencollab.dev/job/GeyserMC/job/Geyser/job/master/lastSuccessfulBuild/artifact/bootstrap/spigot/target/Geyser-Spigot.jar"
GEYSER_FILE = "Geyser-Spigot.jar"
# this plugin is responsible for allowing Bedrock players to play on an "online" Java server (requires Geyser); see here for more info: https://github.com/GeyserMC/Floodgate
FLOODGATE_REMOTE_LOCATION = "https://ci.opencollab.dev/job/GeyserMC/job/Floodgate/job/master/lastSuccessfulBuild/artifact/spigot/target/floodgate-spigot.jar"
FLOODGATE_FILE = "floodgate-spigot.jar"

# domains
GITHUB_DOMAIN = "https://github.com"

# what the spigot server executable starts with
SPIGOT_EXE_PREFIX = "spigot-"
# what the spigot server executable ends with
SPIGOT_EXE_SUFFIX = ".jar"

DATETIME_FORMAT = "%b %-d, %Y at %-I:%M:%S %p"

""" env vars """
VERBOSE = False

""" dynamic vars """
last_server_update_time: str
last_plugin_update_time: str

main_menu_loop_running = True

""" functions """
# returns the path of the current spigot server executable
# TODO: allow user to configure the version to use
def get_current_spigot_exe() -> str:
    # TODO: collect all available versions and default to the highest version
    for file in os.listdir("."):
        if (file[:len(SPIGOT_EXE_PREFIX)] == SPIGOT_EXE_PREFIX) and (file[-len(SPIGOT_EXE_SUFFIX):] == SPIGOT_EXE_SUFFIX):
            return file
    
    print("ERROR!: Could not locate a Spigot server executable within the working directory (" + os.getcwd() + "). Try backing up your files and updating the server.")
    return ""

# returns true if directory existed before the function was called; creates missing directory if specified
def directory_exists(path: str, create_if_missing = True) -> bool:
    # check if directory exists
    if not os.path.isdir(path):
        if VERBOSE:
            print("WARN: The directory could not be found (" + path + ").")
        if create_if_missing:
            if VERBOSE:
                print("Creating a new one...")
            os.makedirs(path)
        return False
    return True

# returns true if file existed before the function was called; creates missing file if specified
def file_exists(path: str, create_if_missing = True) -> bool:
    # check if file exists
    if not os.path.isfile(path):
        if VERBOSE:
            print("WARN: The file could not be found (" + path + ").")
        if create_if_missing:
            if VERBOSE:
                print("Creating a new one...")
            directory_exists(os.path.dirname(path))
            file = open(path, "w")
            file.close()
        return False
    return True

# returns md5 for a Jenkins artifact from its url
def get_md5_jenkins(artifact_url: str) -> str:
    print("Retrieving fingerprint for file verification...")
    subprocess.run(["wget", "--output-document", JENKINS_FINGERPRINT_FILE, artifact_url + JENKINS_FINGERPRINT_SUFFIX])
    if not os.path.isfile(JENKINS_FINGERPRINT_FILE):
        print("ERROR!: The fingerprint from Jenkins could not be retrieved! (" + artifact_url + JENKINS_FINGERPRINT_SUFFIX + ")")
        return ""
    print("Finished retrieving fingerprint!\n")
    
    md5 = ""
    print("Parsing MD5 hash...")
    with open(JENKINS_FINGERPRINT_FILE, "r") as fingerprint:
        for line in fingerprint.readlines():
            if "md5" in line:
                _md5 = line[len("      </h1><div class=\"md5sum\">MD5: "):-len("</div><div>") - 1]
                print("Found MD5 hash (" + _md5 + ")!\n")
                md5 = _md5
    if not md5 == "":
        os.remove(JENKINS_FINGERPRINT_FILE)
        return md5

    os.remove(JENKINS_FINGERPRINT_FILE)
    print("ERROR!: Could not find MD5 hash within the fingerprint retrieved from \"" + artifact_url + JENKINS_FINGERPRINT_SUFFIX + "\"!")
    return ""

# returns true if the md5 hash for local_file matches the md5 hash for the file stored at artifact_url
def check_md5_jenkins(local_file: str, artifact_url: str) -> bool:
    # retrieve md5 hash from server
    md5_remote = get_md5_jenkins(artifact_url)
    if md5_remote == "":
        return False

    # calculate md5 hash of local_file
    print("Calculating MD5 hash of \"" + local_file + "\"...")
    output = subprocess.run(["md5sum", local_file], capture_output = True)
    md5_local = output.stdout.decode("UTF-8")[:MD5_LENGTH]
    print("Finished calculating MD5 hash of \"" + local_file + "\" (" + md5_local + ")!\n")

    # compare the hash retrieved from the server and the hash calculated from local_file
    print("Comparing hashes...")
    if not md5_local == md5_remote:
        print("ERROR!: Hash mismatch! The hash of the local file (MD5: " + md5_local + ") does not match the hash that the remote location is providing (MD5: " + md5_remote + ")!\n")
        return False
    print("Hashes match!\n")
    return True

# accepts the project_overview_url and returns the url of the latest download of it (for github.com)
def get_latest_github_plugin(project_overview_url: str) -> str:
    GITHUB_RELEASES_FILE = ".github_releases.html"

    # construct the url for Github releases
    github_releases_url = project_overview_url + "/releases"

    # download the Github releases page
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("Fetching plugin releases... (" + currenttime + ")", UPDATE_PLUGINS_LOG_FILE)
    subprocess.run(["wget", "--output-document", GITHUB_RELEASES_FILE, github_releases_url])
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("Finished fetching releases! (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)

    # parse the latest plugin url from the downloaded Github releases page
    url = ""
    print_and_log("Parsing latest version...", UPDATE_PLUGINS_LOG_FILE)
    with open(GITHUB_RELEASES_FILE, "r") as file:
        for line in file.readlines():
            # find the first line that contains "href" and ".jar". this should be our latest download, being closest to the top of the screen
            if "href" in line and ".jar" in line:
                # find the opening quotation mark for the url
                lower_index = line.find("href=\"") + len("href=\"") if not line.find("href=\"") == -1 else -1
                # find the closing quotation mark for the url
                upper_index = -1
                for i in range(lower_index, len(line)):
                    if line[i] == '\"':
                        upper_index = i
                        break
                if lower_index == -1 or upper_index == -1:
                    # if no opening or closing quotation mark is found, this is not our download url, so skip to next line
                    continue
                # if both an opening and a closing quotation mark have been found, set the url to be returned and break out
                url = GITHUB_DOMAIN + line[lower_index:upper_index]
                break
    if url == "":
        print_and_log("ERROR!: No download link found in plugin version history!", UPDATE_PLUGINS_LOG_FILE)
    os.remove(GITHUB_RELEASES_FILE)
    return url

# starts the server
def run_server(check_for_updates, restart_server_prompt):
    server_running = True
    file_exists(RUN_SERVER_LOG_FILE)
    while server_running:
        os.system("clear")
        
        if check_for_updates:
            # check for last server update (prompt for download if > 30 days)
            pass
            # TODO [low priority]: implement (use update_server())

            # check for last plugin update (prompt for download if > 30 days)
            pass
            # TODO [low priority]: implement (use update_plugins())

        # check server configs for critical mistakes and warn user to fix them
        # TODO [low priority]: implement (use "[M] - Manage Server" function)

        os.system("clear")

        # log start time
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("[START] Starting Spigot server... (" + currenttime + ")\n", RUN_SERVER_LOG_FILE)

        # get the current server executable
        current_spigot_exe = get_current_spigot_exe()
        if current_spigot_exe == "":
            print_and_log("ERROR!: Could not start server because no Spigot server executable could be found.\n", RUN_SERVER_LOG_FILE)
            currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
            print_and_log("[FAIL] Failed to start server! (" + currenttime + ")\n", RUN_SERVER_LOG_FILE)
            input("Press enter to continue...")
            server_running = False
            break

        # run the server executable
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        # TODO: add options for things like "--nogui"
        print_and_log("Executing \"java -jar " + current_spigot_exe + " --nogui\"... (" + currenttime + ")", RUN_SERVER_LOG_FILE)
        subprocess.run(["java", "-jar", current_spigot_exe, "--nogui"])
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("\"" + current_spigot_exe + "\" has exited. (" + currenttime + ")\n", RUN_SERVER_LOG_FILE)

        # log stop time
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("[STOP] The server has stopped! (" + currenttime + ")\n", RUN_SERVER_LOG_FILE)

        if restart_server_prompt:
            # prompt user if they would like to restart the server
            response = input("Would you like to restart it? [y/N] > ")
            if not response.lower() == "y":
                server_running = False
                break
        else:
            server_running = False
            break

# essentially a bridge to the server management tools (manage_plugins, manage_worlds, manage_users, etc)
def manage_server():
    manage_server_running = True
    while manage_server_running:
        os.system("clear")
        # print header
        print("Geyser-Spigot Server Manager (GSSM) by Nicholas Girga\nVersion " + APP_VERSION + "\n\nRELEASED UNDER THE MIT LICENSE WITH ABSOLUTELY NO WARRANTY\n")

        # print options
        print("Manage Server")
        print(" [S] - Update Server")
        print(" [P] - Manage Plugins")
        print(" [W] - Manage Worlds")
        print(" [U] - Manage Users")
        print(" [B] - Back to the Main Menu")

        # ask user for input
        print()
        response = input("> ")

        match response.lower():
            # update server
            case "s":
                update_server(True, True, False) # do not verify hash; source does not currently provide fingerprint

            # manage plugins
            case "p":
                manage_plugins()

            # manage worlds
            case "w":
                manage_worlds()

            # manage users
            case "u":
                manage_users()

            # back to the main menu
            case "b":
                manage_server_running = False
                return

            # no match
            case _:
                os.system("clear")
                print("ERROR!: Invalid option.\n\nSimply type the character found in the square brackets next to the desired function. For example, if I wanted to run \"[P] - Manage Plugins\", I would simply enter \"p\" and press the enter key.\n")
                input("Press enter to continue...")

def print_plugins(old_plugin_list = ["NULL"]) -> []:
    # create plugin directory if it does not exist
    directory_exists(PLUGIN_DIRECTORY)

    # print plugin directory location
    print(os.getcwd() + PLUGIN_DIRECTORY[1:] + ": ")

    if len(old_plugin_list) == 0 or old_plugin_list[0] == "NULL":
        # create list of files if no old_plugin_list provided
        file_list = [file for file in os.listdir(PLUGIN_DIRECTORY) if (".jar" in file or ".jar.disabled" in file)]
        plugin_list = []
        for file in file_list:
            if (os.path.isfile(PLUGIN_DIRECTORY + "/" + file)):
                plugin_list.append(file)
    else:
        # use old_plugin_list if provided
        plugin_list = old_plugin_list
    
    # print list of files with numbers
    file_count = 1
    for file in plugin_list:
        print(" [" + str(file_count) + "] - " + file)
        file_count += 1
    if len(plugin_list) < 1:
        print(" [ ] - No files found")

    return plugin_list

# allows user to download new plugins, delete plugins, enable/disable them, and update them
def manage_plugins():
    manage_plugins_running = True
    while manage_plugins_running:
        os.system("clear")
        # print header
        print("Geyser-Spigot Server Manager (GSSM) by Nicholas Girga\nVersion " + APP_VERSION + "\n\nRELEASED UNDER THE MIT LICENSE WITH ABSOLUTELY NO WARRANTY\n")
    
        plugin_list = print_plugins()
        
        # print options
        print("\nManage Plugins")
        print(" [A] - Add Plugin")
        print(" [D] - Delete Plugin")
        print(" [U] - Update Plugins")
        print(" [T] - Toggle Plugin On/Off")
        print(" [B] - Back to the Manage Server Menu")

        # ask user for input
        print()
        response = input("> ")

        match response.lower():
            # add plugin
            case "a":
                add_plugin(plugin_list)

            # delete plugin
            case "d":
                delete_plugin(plugin_list)

            # update plugins
            case "u":
                update_plugins(True, True)

            # toggle plugin
            case "t":
                toggle_plugin(plugin_list)

            # back to the Manage Server menu
            case "b":
                manage_plugins_running = False
                return

            # no match
            case _:
                os.system("clear")
                print("ERROR!: Invalid option.\n\nSimply type the character found in the square brackets next to the desired function. For example, if I wanted to run \"[A] - Add Plugin\", I would simply enter \"a\" and press the enter key.\n")
                input("Press enter to continue...")

# asks user how they would like to download a plugin
def add_plugin(plugin_list: []):
    add_plugin_running = True
    while add_plugin_running:
        os.system("clear")
        # print header
        print("Geyser-Spigot Server Manager (GSSM) by Nicholas Girga\nVersion " + APP_VERSION + "\n\nRELEASED UNDER THE MIT LICENSE WITH ABSOLUTELY NO WARRANTY\n")
        
        print_plugins(plugin_list)

        # print options
        print("\nAdd Plugin")
        print(" [D] - Direct Download")
        print(" [H] - GitHub")
        #print(" [L] - GitLab") # TODO: implement
        print(" [B] - Back to the Manage Server Menu")

        # ask user for input
        print()
        response = input("> ")

        match response.lower():
            # direct download
            case "d":
                # prompt user
                os.system("clear")
                print("Please enter a URL to fetch plugin updates from. ")
                print("Direct downloads will NOT do any fancy parsing. ")
                print("GSSM will download ANYTHING at the other end of the link. ")
                print("Even just HTML pages. ")
                print("Make sure this URL will not change (although ideally, the file located there will be updated). ")
                print("Make sure the URL does not need a login of any kind to reach. ")
                print("Because a user may want to download anything from anywhere, no checks are done on direct downloads. ")
                print("Make sure you have the correct URL because GSSM will not be able to tell you if you do not.")
                print("Type `!quit` to return to the Add Plugin menu.\n")
                url = input("URL> ")

                # stop adding source if user asks to quit
                if url == "!quit":
                    continue

                # get plugin name from url
                os.system("clear")
                plugin_name = file_from_url(url)

                # write entry in plugin repos
                file_exists(PLUGIN_REPOS_FILE)
                with open(PLUGIN_REPOS_FILE, "a") as plugin_repos:
                    plugin_repos.write("direct " + plugin_name + " {\n")
                    plugin_repos.write("    url=" + url + "\n")
                    plugin_repos.write("}\n\n")
                print("URL has been recorded to \"" + PLUGIN_REPOS_FILE + "\"!\n")

                # download plugin
                currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
                print("Downloading \"" + plugin_name + "\"... (" + currenttime + ")")
                print("Source: \"" + url + "\"")
                subprocess.run(["wget", "--output-document", PLUGIN_DIRECTORY + "/" + plugin_name, url])
                currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
                print("Finished downloading \"" + plugin_name + "\" from remote location! (" + currenttime + ")\n")

                input("Press enter to continue...")
                add_plugins_running = False
                break

            # GitHub
            # TODO: allow users to set an artifact filter instead of just downloading the first JAR we see
            case "h":
                # prompt user
                os.system("clear")
                print("Please enter a GitHub URL to fetch plugin updates from. ")
                print("Example: `URL> https://github.com/EssentialsX/Essentials`")
                print("Type `!quit` to return to the Add Plugin menu.\n")
                url = input("URL> ")

                # stop adding source if user asks to quit
                if url == "!quit":
                    continue

                os.system("clear")
                # verify that GitHub URL will work with updater
                latest_github_plugin = get_latest_github_plugin(url)
                plugin_name = file_from_url(latest_github_plugin)
                if not latest_github_plugin == "":
                    os.system("clear")
                    print("GitHub URL seems valid. ")
                    # write entry in plugin repos
                    file_exists(PLUGIN_REPOS_FILE)
                    with open(PLUGIN_REPOS_FILE, "a") as plugin_repos:
                        plugin_repos.write("github " + plugin_name + " {\n")
                        plugin_repos.write("    url=" + url + "\n")
                        plugin_repos.write("}\n\n")
                    print("GitHub URL has been recorded to \"" + PLUGIN_REPOS_FILE + "\"!\n")

                    # download plugin
                    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
                    print("Downloading \"" + plugin_name + "\"... (" + currenttime + ")")
                    print("Source: \"" + latest_github_plugin + "\"")
                    subprocess.run(["wget", "--output-document", PLUGIN_DIRECTORY + "/" + file_from_url(latest_github_plugin), GEYSER_REMOTE_LOCATION])
                    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
                    print("Finished downloading \"" + plugin_name + "\" from remote location! (" + currenttime + ")\n")
                    
                    input("Press enter to continue...")
                    add_plugins_running = False
                    break
                else:
                    # warn user of invalid GitHub url
                    os.system("clear")
                    print("ERROR!: An invalid GitHub URL has been entered! (" + url + ")")
                    print("Make sure your URL only contains the GitHub domain, the user or group the project it hosted on, and the project name. ")
                    print("For example, the GitHub URL for EssentialsX is \"https://github.com/EssentialsX/Essentials\" and nothing more.\n")
                    input("Press enter to continue...")
                    add_plugins_running = False
                    break

            # back to the Manage Plugins menu
            case "b":
                add_plugins_running = False
                break

            # no match
            case _:
                os.system("clear")
                print("ERROR!: Invalid option.\n\nSimply type the character found in the square brackets next to the desired source type. \nFor example, if I wanted to add a \"[H] - GitHub\" source, I would simply enter \"h\" and press the enter key.\n")
                input("Press enter to continue...")

# asks user which plugin they would like to delete
def delete_plugin(plugin_list: []):
    delete_plugin_running = True
    while delete_plugin_running:
        os.system("clear")
        # print header
        print("Geyser-Spigot Server Manager (GSSM) by Nicholas Girga\nVersion " + APP_VERSION + "\n\nRELEASED UNDER THE MIT LICENSE WITH ABSOLUTELY NO WARRANTY\n")
            
        print_plugins(plugin_list)

        # print prompt
        print("\nWhich plugin would you like to delete?")
        print("Type `!quit` to return to the Manage Plugins menu.\n")
        plugin_index_str = input("PLUGIN_INDEX> ")
        plugin_index_int = -1

        # return to Manage Plugins menu if player asks to quit
        if plugin_index_str == "!quit":
            return

        # ensure entered index is a number
        try:
            plugin_index_int = int(plugin_index_str)
        except Exception as e:
            os.system("clear")
            print("ERROR!: Plugin index \"" + plugin_index_str + "\" is not a valid index (" + str(e) + ").")
            print("Simply type the number found in the square brackets next to the desired plugin. ")
            print("For example, if I wanted to delete \"[5] - Geyser-Spigot.jar\", I would simply enter \"5\" and press the enter key.\n")
            input("Press enter to continue...")
            delete_plugin_running = False
            break

        # ensure entered index could be parsed properly
        if plugin_index_int < 1:
            os.system("clear")
            print("ERROR!: Plugin index \"" + plugin_index_str + "\" is not a valid index. ")
            print("Simply type the number found in the square brackets next to the desired plugin. ")
            print("For example, if I wanted to delete \"[5] - Geyser-Spigot.jar\", I would simply enter \"5\" and press the enter key.\n")
            input("Press enter to continue...")
            delete_plugin_running = False
            break

        # remove file (if within index bounds)
        if not plugin_index_int >= len(plugin_list) + 1:
            file_name = PLUGIN_DIRECTORY + "/" + plugin_list[plugin_index_int - 1]
            try:
                os.remove(file_name)
                os.system("clear")
                print("Deleted \"" + file_name + "\"!")
                print("Removed source from \"" + PLUGIN_REPOS_FILE + "\"!\n")
                input("Press enter to continue...")
                delete_plugin_running = False
                break

            except Exception as e:
                os.system("clear")
                print("ERROR!: Could not remove file at \"" + file_name + "\"!\n")
                input("Press enter to continue...")
                delete_plugin_running = False
                break
        else:
            os.system("clear")
            print("ERROR!: The entered index (" + str(plugin_index_int) + ") is larger than the quantity of plugins (" + str(len(plugin_list)) + ")!\n")
            input("Press enter to continue...")
            delete_plugin_running = False
            break

# asks user which plugin they would like to toggle on/off
def toggle_plugin(plugin_list: []):
    os.system("clear")
    # print header
    print("Geyser-Spigot Server Manager (GSSM) by Nicholas Girga\nVersion " + APP_VERSION + "\n\nRELEASED UNDER THE MIT LICENSE WITH ABSOLUTELY NO WARRANTY\n")
    

    print_plugins(plugin_list)

# allows user to view, rename, and delete worlds
def manage_worlds():
    pass

# allows user to ban/unban
def manage_users():
    pass

# installs and updates the base server files
def update_server(clear_on_start: bool, pause_when_done: bool, verify_hash: bool):
    if clear_on_start:
        os.system("clear")
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    file_exists(UPDATE_SERVER_LOG_FILE)
    print_and_log("[START] Starting server update... (" + currenttime + ")\n", UPDATE_SERVER_LOG_FILE)
    
    # download build tools
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("Downloading \"" + BUILD_TOOLS_FILE + "\"... (" + currenttime + ")", UPDATE_SERVER_LOG_FILE)
    print_and_log("Source: \"" + BUILD_TOOLS_REMOTE_LOCATION + "\"", UPDATE_SERVER_LOG_FILE)
    subprocess.run(["wget", "--output-document", BUILD_TOOLS_FILE, BUILD_TOOLS_REMOTE_LOCATION])
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("Finished downloading \"" + BUILD_TOOLS_FILE + "\" from remote location! (" + currenttime + ")\n", UPDATE_SERVER_LOG_FILE)

    # verify hash of build tools
    if verify_hash:
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("Verifying the integrity of the downloaded file... (" + currenttime + ")", UPDATE_SERVER_LOG_FILE)
        if not check_md5_jenkins(BUILD_TOOLS_FILE, BUILD_TOOLS_REMOTE_LOCATION):
            print_and_log("ERROR!: BuildTools failed file verification. This can indicate numerous things, but the most common is an interrupted download.", UPDATE_SERVER_LOG_FILE)
            print_and_log("Give the update a couple more tries. If file verification continues to be problematic, you can update the server without file verification by running `gssm update server --skip-hash`.", UPDATE_SERVER_LOG_FILE)
            print_and_log("Be aware that this will disable file verification, meaning you may be running corrupted and incomplete files.\n", UPDATE_SERVER_LOG_FILE)
            currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
            print_and_log("[FAIL] Failed updating server! (" + currenttime + ")\n", UPDATE_SERVER_LOG_FILE)
            input("Press enter to continue...")
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("File verification passed! (" + currenttime + ")\n", UPDATE_SERVER_LOG_FILE)
        
    # run/build
    # TODO: add the ability to specify the version of Minecraft the server will be compatible with (e.g. adds "--rev 1.18.2" to the end of the command)
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("Executing \"java -jar ./BuildTools.jar\"... (" + currenttime + ")", UPDATE_SERVER_LOG_FILE)
    print_and_log("See \"" + BUILD_TOOLS_LOG_FILE + "\" for log information about the \"BuildTools.jar\" subprocess.", UPDATE_SERVER_LOG_FILE)
    subprocess.run(["java", "-jar", BUILD_TOOLS_FILE])
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("\"" + BUILD_TOOLS_FILE + "\" has exited. (" + currenttime + ")\n", UPDATE_SERVER_LOG_FILE)
    
    # log time of completion
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("[FINISH] Finished updating server! (" + currenttime + ")\n", UPDATE_SERVER_LOG_FILE)

    if pause_when_done:
        input("Press enter to continue...")
    
# installs and updates core plugins such as Geyser
# I intend to eventually make a plugin manager that will allow you to add custom sources, so this function can update other plugins as well
# TODO: implement updates with plugin_repos file
def update_plugins(pause_when_done: bool, verify_hash: bool):
    os.system("clear")
    file_exists(UPDATE_PLUGINS_LOG_FILE)
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("[START] Starting plugins update... (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)
        
    # check if plugin directory exists; if not, create it
    directory_exists(PLUGIN_DIRECTORY)

    # download geyser
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("Downloading \"" + PLUGIN_DIRECTORY + "/" + GEYSER_FILE + "\"... (" + currenttime + ")", UPDATE_PLUGINS_LOG_FILE)
    print_and_log("Source: \"" + GEYSER_REMOTE_LOCATION + "\"", UPDATE_PLUGINS_LOG_FILE)
    subprocess.run(["wget", "--output-document", PLUGIN_DIRECTORY + "/" + GEYSER_FILE, GEYSER_REMOTE_LOCATION])
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("Finished downloading \"" + PLUGIN_DIRECTORY + "/" + GEYSER_FILE + "\" from remote location! (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)

    # verify hash of geyser
    if verify_hash:
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("Verifying the integrity of \"" + PLUGIN_DIRECTORY + "/" + GEYSER_FILE + "\"... (" + currenttime + ")", UPDATE_PLUGINS_LOG_FILE)
        if not check_md5_jenkins(PLUGIN_DIRECTORY + "/" + GEYSER_FILE, GEYSER_REMOTE_LOCATION):
            print_and_log("ERROR!: Geyser failed file verification. This can indicate numerous things, but the most common is an interrupted download.", UPDATE_PLUGINS_LOG_FILE)
            print_and_log("Give the update a couple more tries. If file verification continues to be problematic, you can update plugins without file verification by running `gssm update plugins --skip-hash`.", UPDATE_PLUGINS_LOG_FILE)
            print_and_log("Be aware that this will disable file verification, meaning you may be running corrupted and incomplete files.\n", UPDATE_PLUGINS_LOG_FILE)
            currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
            print_and_log("[FAIL] Failed updating plugins! (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)
            input("Press enter to continue...")
            return
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("File verification passed! (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)

    # download floodgate
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("Downloading \"" + PLUGIN_DIRECTORY + "/" + FLOODGATE_FILE + "\"... (" + currenttime + ")", UPDATE_PLUGINS_LOG_FILE)
    print_and_log("Source: \"" + FLOODGATE_REMOTE_LOCATION + "\"", UPDATE_PLUGINS_LOG_FILE)
    subprocess.run(["wget", "--output-document", PLUGIN_DIRECTORY + "/" + FLOODGATE_FILE, FLOODGATE_REMOTE_LOCATION])
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("Finished downloading \"" + PLUGIN_DIRECTORY + "/" + FLOODGATE_FILE + "\" from remote location! (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)
    
    # verify hash of floodgate
    if verify_hash:
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("Verifying the integrity of \"" + PLUGIN_DIRECTORY + "/" + FLOODGATE_FILE + "\"... (" + currenttime + ")", UPDATE_PLUGINS_LOG_FILE)
        if not check_md5_jenkins(PLUGIN_DIRECTORY + "/" + FLOODGATE_FILE, FLOODGATE_REMOTE_LOCATION):
            print_and_log("ERROR!: Floodgate failed file verification. This can indicate numerous things, but the most common is an interrupted download.", UPDATE_PLUGINS_LOG_FILE)
            print_and_log("Give the update a couple more tries. If file verification continues to be problematic, you can update plugins without file verification by running `gssm update plugins --skip-hash`", UPDATE_PLUGINS_LOG_FILE)
            print_and_log("Be aware that this will disable file verification, meaning you may be running corrupted and incomplete files.\n", UPDATE_PLUGINS_LOG_FILE)
            currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
            print_and_log("[FAIL] Failed updating plugins! (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)
            input("Press enter to continue...")
            return
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("File verification passed! (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)

    # log time of completion
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("[FINISH] Finished updating plugins! (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)

    if (pause_when_done):
        input("Press enter to continue...")

# show last update times
def show_last_update_times(pause_when_done=True):
    os.system("clear")
    
    last_server_update_time = "No Log Found"

    # fetch last server update time
    if os.path.isfile(UPDATE_SERVER_LOG_FILE):
        with open(UPDATE_SERVER_LOG_FILE, "r") as file:
            lines = file.readlines()
            reversed_lines = [ele for ele in reversed(lines)]
            for line in reversed_lines:
                if "[FAIL]" in line:
                    last_server_update_time = line[line.index("(") + 1:-len(")") - 1] + " [UPDATE FAILED!]"
                    break
                if "[FINISH]" in line:
                    last_server_update_time = line[line.index("(") + 1:-len(")") - 1]
                    break
    else:
        if (VERBOSE):
            print("WARN: There is no logged time for the last update to the server")

    last_plugin_update_time = "No Log Found"

    # fetch last plugin update time
    if os.path.isfile(UPDATE_PLUGINS_LOG_FILE):
        with open(UPDATE_PLUGINS_LOG_FILE, "r") as file:
            lines = file.readlines()
            reversed_lines = [ele for ele in reversed(lines)]
            for line in reversed_lines:
                if "[FAIL]" in line:
                    last_plugin_update_time = line[line.index("(") + 1:-len(")") - 1] + " [UPDATE FAILED!]"
                    break
                if "[FINISH]" in line:
                    last_plugin_update_time = line[line.index("(") + 1:-len(")") - 1]
                    break
    else:
        if VERBOSE:
            print("WARN: There is no logged time for the last update to the plugins")
            
    # print
    print("Last Server Update Time: \'" + last_server_update_time + "\'")
    print("Last Plugin Update Time: \'" + last_plugin_update_time + "\'\n")
            
    if pause_when_done:
        input("Press enter to continue...")

# check launch arguments
def check_launch_arguments():
    args = sys.argv[1:]

    if len(args) > 0:
        if "-v" in args or "--verbose" in args:
            VERBOSE = True

        if ((args[0] == "-v" or args[0] == "--verbose") and len(args) == 1):
            return

        match args[0]:
            # show how to pass commands directly into GSSM
            case "help":
                print("GSSM " + APP_VERSION + " Help:")
                print("`gssm` - Starts the menu interface. ")
                print("`gssm help` - Shows how to use the direct command interface. ")
                print("`gssm update [type]` - Updates files. Type can be `server`, `plugins` or blank. Use `--skip-hash` to skip file verification. ")
                print("`gssm run` - Starts the server. Use `--exit-on-stop` to stop the restart prompt. ")
                print("`gssm history` - Shows the last times the server and the plugins were updated. ")
                print("`gssm version` - Shows the current version of GSSM being used. ")
                print()
                print("You can add `-v` or `--verbose` to the end of almost anything to get a bit more information. ")
                sys.exit()

            # starts the server
            case "run":
                check_for_updates = True
                restart_server_prompt = True

                if len(args) >= 2:
                    check_for_updates = (not "--ignore-updates" in args)
                    restart_server_prompt = (not "--exit-on-stop" in args)

                run_server(check_for_updates, restart_server_prompt)

                sys.exit()

            # update server
            case "update":
                if len(args) >= 2:
                    match args[1]:
                        case "server":
                            # TODO: implement "--skip-hash" when BuildTools provides a remote hash to check
                            # skip_hash = "--skip-hash" in args
                            update_server(False, False, False) # update_server(False, False, not skip_hash)
                        case "plugins":
                            skip_hash = "--skip-hash" in args
                            update_plugins(False, not skip_hash)
                        case "--skip-hash":
                            update_server(False, False, False)
                            update_plugins(False, False)
                        case _:
                            sys.exit("ERROR!: \"" + args[1] + "\" is not a valid update option. Use `gssm help` to view how to use the update command properly.")
                else:
                    update_server(False, False, False) # set to (False, False, True) when file verification for server works
                    update_plugins(False, True)

                sys.exit()

            # show last update times
            case "history":
                show_last_update_times(False)
                sys.exit()

            # prints APP_VERSION
            case "version" | "--version":
                print("Geyser-Spigot Server Manager v" + APP_VERSION + " by Nicholas Girga")
                sys.exit()

            # no match
            case _:
                sys.exit("ERROR!: Invalid launch arguments given (" + str(args)[1:-1] + "). Use `gssm help` to view available launch arguments.")

# returns the file name of the url passed into it
def file_from_url(url: str) -> str:
    return url[len(os.path.dirname(url)) + 1:]

# prints message to terminal and logs it in the specified log
def print_and_log(message: str, log: str, new_line_in_file = True):
    print(message)
    with open(log, "a") as file:
        file.write(message + "\n" if new_line_in_file else message)

""" initialize """
# check launch arguments
check_launch_arguments()

# check if GSSM directory exists; if not, create it
directory_exists(GSSM_DIRECTORY)

# start loop for main menu
while main_menu_loop_running:
    os.system("clear")
    # print header
    print("Geyser-Spigot Server Manager (GSSM) by Nicholas Girga\nVersion " + APP_VERSION + "\n\nRELEASED UNDER THE MIT LICENSE WITH ABSOLUTELY NO WARRANTY\n")
        
    # print options
    print("What would you like to do?")
    print(" [R] - Run Server")
    print(" [M] - Manage Server") # TODO [low priority]: implement and nest options for things such as plugins, worlds, players, and settings
    print(" [T] - Show Last Update Time")
    print(" [Q] - Quit")
    
    # ask user for input
    print()
    response = input("> ")
    
    match response.lower():
        # run server
        case "r":
            run_server(True, True)

        # manage server
        case "m":
            manage_server()

        # show last update times
        case "t":
            show_last_update_times()
        
        # quit
        case "q":
            os.system("clear")
            main_menu_loop_running = False
        
        # no match
        case _:
            os.system("clear")
            print("ERROR!: Invalid option.\n\nSimply type the character found in the square brackets next to the desired function. \nFor example, if I wanted to run \"[T] - Show Last Update Time\", I would simply enter \"t\" and press the enter key.\n")
            input("Press enter to continue...")
