#!/usr/bin/python3
# name-grabber
# Version 3.3
# Nicholas Girga
# Released under MIT license with ABSOLUTELY NO WARRANTY

# This program helps maintain a Minecraft Spigot server that utilizes Geyser

# TODO:
# ESSENTIAL FOR MOVING FORWARD:
#   - read/write to/from files properly, so there doesn't need to be an entire file for each piece of data that needs storing
#     - we need to be able to store the name of the spigot executable that we want GSSM to call, but the current system isn't an elegant solution
#     - we want to construct real logs for the behavior of GSSM and potentially information we get from utilities like Spigot, Geyser, or Floodgate
#     - we want to be able to create systems that track files and their states (like the plugin, world, and player managers), but this wouldn't work well with our current storage solution
#
# NEEDED, BUT LATER:
#   - implement plugin manager
#   - implement world manager
#   - implement player manager
#   - implement hash verification for updates to ensure files have not been corrupted or tampered with
#   - implement launch option (for both the CLI menu and the direct commands) to use a custom Java version; e.g. "--java /usr/lib/jvm/java-11-openjdk/bin/java"

""" imports """
import datetime, os, subprocess, sys, urllib

""" constants """
MD5_LENGTH = 32

GSSM_DIRECTORY = "./.gssm" # remove trailing forward/back slashes

LAST_SERVER_UPDATE_TIME_FILE = GSSM_DIRECTORY + "/last_server_update_time"
LAST_PLUGIN_UPDATE_TIME_FILE = GSSM_DIRECTORY + "/last_plugin_update_time"

# added to the end of a Jenkins URL to see the web page with the md5 on it
JENKINS_FINGERPRINT_SUFFIX = "/*fingerprint*/"
# what to save the Jenkins fingerprint webpage as
JENKINS_FINGERPRINT_FILE = ".jenkins_fingerprint.html"

# this tool is responsible for building the spigot server executable; see here for more info: https://www.spigotmc.org/wiki/buildtools/#what-is-it
BUILD_TOOLS_REMOTE_LOCATION = "https://hub.spigotmc.org/jenkins/job/BuildTools/lastSuccessfulBuild/artifact/target/BuildTools.jar"
BUILD_TOOLS_FILE = "BuildTools.jar"

PLUGIN_DIRECTORY = "./plugins"
# this plugin is responsible for allowing Bedrock players to connect to Java servers; see here for more info: https://github.com/GeyserMC/Geyser
GEYSER_REMOTE_LOCATION = "https://ci.opencollab.dev/job/GeyserMC/job/Geyser/job/master/lastSuccessfulBuild/artifact/bootstrap/spigot/target/Geyser-Spigot.jar"
GEYSER_FILE = "Geyser-Spigot.jar"
# this plugin is responsible for allowing Bedrock players to play on an "online" Java server (requires Geyser); see here for more info: https://github.com/GeyserMC/Floodgate
FLOODGATE_REMOTE_LOCATION = "https://ci.opencollab.dev/job/GeyserMC/job/Floodgate/job/master/lastSuccessfulBuild/artifact/spigot/target/floodgate-spigot.jar"
FLOODGATE_FILE = "floodgate-spigot.jar"

# what the spigot server executable starts with
SPIGOT_EXE_PREFIX = "spigot-"
# what the spigot server executable ends with
SPIGOT_EXE_SUFFIX = ".jar"

""" env vars """
VERBOSE = False

""" dynamic vars """
last_server_update_time: str
last_plugin_update_time: str

main_menu_loop_running = True

""" functions """
# returns the path of the current spigot server executable
# TODO: allow user to configure the version to use
def get_current_spigot_exe() -> str:
    # TODO: collect all available versions and default to the highest version
    for file in os.listdir("."):
        if (file[:len(SPIGOT_EXE_PREFIX)] == SPIGOT_EXE_PREFIX) and (file[-len(SPIGOT_EXE_SUFFIX):] == SPIGOT_EXE_SUFFIX):
            return file
    
    print("ERROR!: Could not locate a Spigot server executable within the working directory (" + os.getcwd() + "). Try backing up your files and updating the server.")
    return ""

# returns true if directory existed before the function was called; creates missing directory if specified
def directory_exists(path: str, create_if_missing = True) -> bool:
    # check if directory exists
    if (not os.path.isdir(path)):
        if (VERBOSE):
            print("WARN: The directory could not be found (" + path + "). Creating a new one...")
        if (create_if_missing):
            os.mkdir(path)
        return False
    return True

# returns md5 for a Jenkins artifact from its url
def get_md5_jenkins(artifact_url: str) -> str:
    print("Retrieving fingerprint for file verification...")
    subprocess.run(["curl", "-o", JENKINS_FINGERPRINT_FILE, artifact_url + JENKINS_FINGERPRINT_SUFFIX])
    if not os.path.isfile(JENKINS_FINGERPRINT_FILE):
        print("ERROR!: The fingerprint from Jenkins could not be retrieved! (" + artifact_url + JENKINS_FINGERPRINT_SUFFIX + ")")
        return ""
    print("Finished retrieving fingerprint!\n")
    
    md5 = ""
    print("Parsing MD5 hash...")
    with open(JENKINS_FINGERPRINT_FILE, "r") as fingerprint:
        for line in fingerprint.readlines():
            if ("md5" in line):
                _md5 = line[len("      </h1><div class=\"md5sum\">MD5: "):-len("</div><div>") - 1]
                print("Found MD5 hash (" + _md5 + ")!\n")
                md5 = _md5
    if not md5 == "":
        os.remove(JENKINS_FINGERPRINT_FILE)
        return md5

    os.remove(JENKINS_FINGERPRINT_FILE)
    print("ERROR!: Could not find MD5 hash within the fingerprint retrieved from \"" + artifact_url + JENKINS_FINGERPRINT_SUFFIX + "\"!")
    return ""

# returns true if the md5 hash for local_file matches the md5 hash for the file stored at artifact_url
def check_md5_jenkins(local_file: str, artifact_url: str) -> bool:
    # retrieve md5 hash from server
    md5_remote = get_md5_jenkins(artifact_url)
    if md5_remote == "":
        return False

    # calculate md5 hash of local_file
    print("Calculating MD5 hash of \"" + local_file + "\"...")
    output = subprocess.run(["md5sum", local_file], capture_output = True)
    md5_local = output.stdout.decode("UTF-8")[:MD5_LENGTH]
    print("Finished calculating MD5 hash of \"" + local_file + "\" (" + md5_local + ")!\n")

    # compare the hash retrieved from the server and the hash calculated from local_file
    print("Comparing hashes...")
    if not md5_local == md5_remote:
        print("ERROR!: Hash mismatch! The hash of the local file (MD5: " + md5_local + ") does not match the hash that the remote location is providing (MD5: " + md5_remote + ")!\n")
        return False
    print("Hashes match!\n")
    return True

# starts the server
def run_server(check_for_updates, restart_server_prompt):
    server_running = True
    while server_running:
        os.system("clear")
        
        if (check_for_updates):
            # check for last server update (prompt for download if > 30 days)
            pass
            # TODO [low priority]: implement (use update_server())

            # check for last plugin update (prompt for download if > 30 days)
            pass
            # TODO [low priority]: implement (use update_plugins())

        # check server configs for critical mistakes and warn user to fix them
        # TODO [low priority]: implement (use "[M] - Manage Server" function)

        os.system("clear")
        print("Starting Spigot server...\n")
        # log start time
        # TODO: implement

        # get the current server executable
        current_spigot_exe = get_current_spigot_exe()
        if current_spigot_exe == "":
            print("ERROR!: Could not start server because no Spigot server executable could be found.\n")
            input("Press enter to return to the main menu...")
            server_running = False
            break

        # run the server executable
        # TODO: add options for things like "--nogui"
        print("Executing \"java -jar " + current_spigot_exe + " --nogui\"...")
        subprocess.run(["java", "-jar", current_spigot_exe, "--nogui"])
        print("\"" + current_spigot_exe + "\" has exited.\n")

        # log stop time
        # TODO: implement

        if (restart_server_prompt):
            # prompt user if they would like to restart the server
            print()
            response = input("The server has stopped. Would you like to restart it? [y/N] > ")
            if (not response.lower() == "y"):
                server_running = False
                break
        else:
            server_running = False
            break

# installs and updates the base server files
def update_server(clear_on_start: bool, pause_when_done: bool, verify_hash: bool):
    if (clear_on_start):
        os.system("clear")
    print("Updating server...\n")
    
    # download files
    print("Downloading \"" + BUILD_TOOLS_FILE + "\"...")
    print("Source: \"" + BUILD_TOOLS_REMOTE_LOCATION + "\"")
    subprocess.run(["curl", "-o", BUILD_TOOLS_FILE, BUILD_TOOLS_REMOTE_LOCATION])
    print("Finished downloading \"" + BUILD_TOOLS_FILE + "\" from remote location!\n")

    if verify_hash:
        if not check_md5_jenkins(BUILD_TOOLS_FILE, BUILD_TOOLS_REMOTE_LOCATION):
            print("ERROR!: BuildTools failed file verification. This can indicate numerous things, but the most common is an interupped download.")
            print("Give the update a couple more tries. If file verification continues to be problematic, you can update the server without file verification by running `gssm update server --skip-hash`.")
            print("Be aware that this will disable file verification, meaning you may be running corrupted and incomplete files.\n")
            input("Press enter to return to the main menu...")
        
    # run/build
    # TODO: add the ability to specify the version of Minecraft the server will be compatible with (e.g. adds "--rev 1.18.2" to the end of the command)
    print("Executing \"java -jar ./BuildTools.jar\"...")
    subprocess.run(["java", "-jar", BUILD_TOOLS_FILE])
    print("\"" + BUILD_TOOLS_FILE + "\" has exited.\n")
    
    # log time of completion
    currenttime = datetime.datetime.now().strftime("%b %-d, %Y at %-I:%M:%S %p")
    print("Finished updating server! (" + currenttime + ")\n")
    with open(LAST_SERVER_UPDATE_TIME_FILE, "w") as file:
        file.write(currenttime)
        
    if (pause_when_done):
        input("Press enter to return to the main menu...")
    
# installs and updates core plugins such as Geyser
# I intend to eventually make a plugin manager that will allow you to add custom sources, so this function can update other plugins as well
def update_plugins(pause_when_done: bool, verify_hash: bool):
    os.system("clear")
    print("Updating plugins...\n")
        
    # check if plugin directory exists; if not, create it
    directory_exists(PLUGIN_DIRECTORY)

    # download geyser
    print("Downloading \"" + PLUGIN_DIRECTORY + "/" + GEYSER_FILE + "\"...")
    print("Source: \"" + GEYSER_REMOTE_LOCATION + "\"")
    subprocess.run(["curl", "-o", PLUGIN_DIRECTORY + "/" + GEYSER_FILE, GEYSER_REMOTE_LOCATION])
    print("Finished downloading \"" + PLUGIN_DIRECTORY + "/" + GEYSER_FILE + "\" from remote location!\n")

    if verify_hash:
        if not check_md5_jenkins(PLUGIN_DIRECTORY + "/" + GEYSER_FILE, GEYSER_REMOTE_LOCATION):
            print("ERROR!: Geyser failed file verification. This can indicate numerous things, but the most common is an interupped download.")
            print("Give the update a couple more tries. If file verification continues to be problematic, you can update plugins without file verification by running `gssm update plugins --skip-hash`.")
            print("Be aware that this will disable file verification, meaning you may be running corrupted and incomplete files.\n")
            input("Press enter to return to the main menu...")
            return

    print("Downloading \"" + PLUGIN_DIRECTORY + "/" + FLOODGATE_FILE + "\"...")
    print("Source: \"" + FLOODGATE_REMOTE_LOCATION + "\"")
    subprocess.run(["curl", "-o", PLUGIN_DIRECTORY + "/" + FLOODGATE_FILE, FLOODGATE_REMOTE_LOCATION])
    print("Finished downloading \"" + PLUGIN_DIRECTORY + "/" + FLOODGATE_FILE + "\" from remote location!\n")
    
    if verify_hash:
        if not check_md5_jenkins(PLUGIN_DIRECTORY + "/" + FLOODGATE_FILE, FLOODGATE_REMOTE_LOCATION):
            print("ERROR!: Floodgate failed file verification. This can indicate numerous things, but the most common is an interupped download.")
            print("Give the update a couple more tries. If file verification continues to be problematic, you can update plugins without file verification by running `gssm update plugins --skip-hash`")
            print("Be aware that this will disable file verification, meaning you may be running corrupted and incomplete files.\n")
            input("Press enter to return to the main menu...")
            return

    # log time of completion
    currenttime = datetime.datetime.now().strftime("%b %-d, %Y at %-I:%M:%S %p")
    print("Finished updating plugins! (" + currenttime + ")\n")
    with open(LAST_PLUGIN_UPDATE_TIME_FILE, "w") as file:
        file.write(currenttime)

    if (pause_when_done):
        input("Press enter to return to the main menu...")

# show last update times
def show_last_update_times(pause_when_done=True):
    os.system("clear")
    
    # fetch last server update time
    if (os.path.isfile(LAST_SERVER_UPDATE_TIME_FILE)):
        try:
            output = subprocess.run(["cat", LAST_SERVER_UPDATE_TIME_FILE], capture_output=True)
            last_server_update_time = output.stdout.decode("UTF-8")
        except Exception as e:
            print("ERROR!: Could not fetch the last time that the server was updated! (" + str(e) + ")")
            last_server_update_time = "FAILED TO CHECK!"
    else:
        if (VERBOSE):
            print("WARN: There is no logged time for the last update to the server")
        last_server_update_time = "No History"

    # fetch last plugin update time
    if (os.path.isfile(LAST_PLUGIN_UPDATE_TIME_FILE)):
        try:
            output = subprocess.run(["cat", LAST_PLUGIN_UPDATE_TIME_FILE], capture_output=True)
            last_plugin_update_time = output.stdout.decode("UTF-8")
        except Exception as e:
            print("ERROR!: Could not fetch the last time that the plugins were updated! (" + str(e) + ")")
            last_plugin_update_time = "FAILED TO CHECK!"
    else:
        if (VERBOSE):
            print("WARN: There is no logged time for the last update to the plugins")
        last_plugin_update_time = "No History"
            
    # print
    print("Last Server Update Time: \'" + last_server_update_time + "\'")
    print("Last Plugin Update Time: \'" + last_plugin_update_time + "\'\n")
            
    if (pause_when_done):
        input("Press enter to return to the main menu...")

# check launch arguments
def check_launch_arguments():
    args = sys.argv[1:]

    if (len(args) > 0):
        if ("-v" in args or "--verbose" in args):
            VERBOSE = True

        if ((args[0] == "-v" or args[0] == "--verbose") and len(args) == 1):
            return

        match args[0]:
            # show how to pass commands directly into GSSM
            case "help":
                print("no.")
                sys.exit()

            # starts the server
            case "run":
                check_for_updates = True
                restart_server_prompt = True

                if (len(args) >= 2):
                    check_for_updates = (not "--ignore-updates" in args)
                    restart_server_prompt = (not "--exit-on-stop" in args)

                run_server(check_for_updates, restart_server_prompt)

                sys.exit()

            # update server
            case "update":
                if (len(args) >= 2):
                    match args[1]:
                        case "server":
                            # TODO: implement "--skip-hash" when BuildTools provides a remote hash to check
                            # skip_hash = "--skip-hash" in args
                            update_server(False, False, False) # update_server(False, False, not skip_hash)
                        case "plugins":
                            skip_hash = "--skip-hash" in args
                            update_plugins(False, not skip_hash)
                        case "--skip-hash":
                            update_server(False, False, False)
                            update_plugins(False, False)
                        case _:
                            sys.exit("ERROR!: \"" + args[1] + "\" is not a valid update option. Use \"gssm help\" to view how to use the update command properly.")
                else:
                    update_server(False, False, False) # set to (False, False, True) when file verification for server works
                    update_plugins(False, True)

                sys.exit()

            # show last update times
            case "history":
                show_last_update_times(False)
                sys.exit()

            # default or failure to match input
            case _:
                sys.exit("ERROR!: Invalid launch arguments given (" + str(args)[1:-1] + "). Use \"gssm help\" to view available launch arguments.")

""" initialize """
# check launch arguments
check_launch_arguments()

# check if GSSM directory exists; if not, create it
directory_exists(GSSM_DIRECTORY)

# start loop for main menu
while main_menu_loop_running:
    os.system("clear")
    # print header
    print("Geyser-Spigot Server Manager (GSSM) by Nicholas Girga\nVersion 1.0\n\nRELEASED UNDER THE MIT LICENSE WITH ABSOLUTELY NO WARRANTY\n")
        
    # print options
    print("What would you like to do?")
    print(" [R] - Run Server")
    #print(" [M] - Manage Server") # TODO [low priority]: implement and nest options for things such as plugins, worlds, players, and settings
    print(" [S] - Update Server") # TODO: merge update functions in update menu. create GSSM self-update function
    print(" [P] - Update Plugins")
    print(" [T] - Show Last Update Time")
    print(" [Q] - Quit")
    
    # ask user for input
    print()
    response = input("> ")
    
    match response.lower():
        # run server
        case "r":
            run_server(True, True)

        # update server
        case "s":
            update_server(True, True, False) # do not verify hash; source does not currently provide fingerprint
            
        # update plugins
        case "p":
            update_plugins(True, True)
            
        # show last update times
        case "t":
            show_last_update_times()
        
        # quit
        case "q":
            os.system("clear")
            main_menu_loop_running = False
        
        # default or failure to match input
        case _:
            os.system("clear")
            print("ERROR!: Invalid option.\n\nSimply type the character found in the square brackets next to the desired function. For example, if I wanted to run \"[T] - Show Last Update Time\", I would simply enter \"t\" and press the enter key.\n")
            input("Press enter to return to the main menu...")
