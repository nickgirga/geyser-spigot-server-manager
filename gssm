#!/usr/bin/python3
# name-grabber
# Version 3.3
# Nicholas Girga
# Released under MIT license with ABSOLUTELY NO WARRANTY

# This program helps maintain a Minecraft Spigot server that utilizes Geyser

# TODO:
# - download files to temporary directory, so they don't overwrite the originals until they are verified
# - implement plugin manager
# - implement world manager
# - implement player manager
# - implement launch option (for both the CLI menu and the direct commands) to use a custom Java version; e.g. "--java /usr/lib/jvm/java-11-openjdk/bin/java"

""" imports """
import datetime, os, subprocess, sys, urllib

""" constants """
MD5_LENGTH = 32

GSSM_DIRECTORY = os.path.expanduser("~") + "/.local/share/gssm" # remove trailing forward/back slashes

# log files
UPDATE_SERVER_LOG_FILE = GSSM_DIRECTORY + "/logs/update_server.log"
UPDATE_PLUGINS_LOG_FILE = GSSM_DIRECTORY + "/logs/update_plugins.log"
RUN_SERVER_LOG_FILE = GSSM_DIRECTORY + "/logs/run_server.log"

# BuildTools.jar log file
BUILD_TOOLS_LOG_FILE = os.getcwd() + "/BuildTools.log.txt"

# added to the end of a Jenkins URL to see the web page with the md5 on it
JENKINS_FINGERPRINT_SUFFIX = "/*fingerprint*/"
# what to save the Jenkins fingerprint webpage as
JENKINS_FINGERPRINT_FILE = ".jenkins_fingerprint.html"

# this tool is responsible for building the spigot server executable; see here for more info: https://www.spigotmc.org/wiki/buildtools/#what-is-it
BUILD_TOOLS_REMOTE_LOCATION = "https://hub.spigotmc.org/jenkins/job/BuildTools/lastSuccessfulBuild/artifact/target/BuildTools.jar"
BUILD_TOOLS_FILE = "BuildTools.jar"

PLUGIN_DIRECTORY = "./plugins"
# this plugin is responsible for allowing Bedrock players to connect to Java servers; see here for more info: https://github.com/GeyserMC/Geyser
GEYSER_REMOTE_LOCATION = "https://ci.opencollab.dev/job/GeyserMC/job/Geyser/job/master/lastSuccessfulBuild/artifact/bootstrap/spigot/target/Geyser-Spigot.jar"
GEYSER_FILE = "Geyser-Spigot.jar"
# this plugin is responsible for allowing Bedrock players to play on an "online" Java server (requires Geyser); see here for more info: https://github.com/GeyserMC/Floodgate
FLOODGATE_REMOTE_LOCATION = "https://ci.opencollab.dev/job/GeyserMC/job/Floodgate/job/master/lastSuccessfulBuild/artifact/spigot/target/floodgate-spigot.jar"
FLOODGATE_FILE = "floodgate-spigot.jar"

# what the spigot server executable starts with
SPIGOT_EXE_PREFIX = "spigot-"
# what the spigot server executable ends with
SPIGOT_EXE_SUFFIX = ".jar"

DATETIME_FORMAT = "%b %-d, %Y at %-I:%M:%S %p"

""" env vars """
VERBOSE = False

""" dynamic vars """
last_server_update_time: str
last_plugin_update_time: str

main_menu_loop_running = True

""" functions """
# returns the path of the current spigot server executable
# TODO: allow user to configure the version to use
def get_current_spigot_exe() -> str:
    # TODO: collect all available versions and default to the highest version
    for file in os.listdir("."):
        if (file[:len(SPIGOT_EXE_PREFIX)] == SPIGOT_EXE_PREFIX) and (file[-len(SPIGOT_EXE_SUFFIX):] == SPIGOT_EXE_SUFFIX):
            return file
    
    print("ERROR!: Could not locate a Spigot server executable within the working directory (" + os.getcwd() + "). Try backing up your files and updating the server.")
    return ""

# returns true if directory existed before the function was called; creates missing directory if specified
def directory_exists(path: str, create_if_missing = True) -> bool:
    # check if directory exists
    if not os.path.isdir(path):
        if VERBOSE:
            print("WARN: The directory could not be found (" + path + ").")
        if create_if_missing:
            if VERBOSE:
                print("Creating a new one...")
            os.makedirs(path)
        return False
    return True

# returns true if file existed before the function was called; creates missing file if specified
def file_exists(path: str, create_if_missing = True) -> bool:
    # check if file exists
    if not os.path.isfile(path):
        if VERBOSE:
            print("WARN: The file could not be found (" + path + ").")
        if create_if_missing:
            if VERBOSE:
                print("Creating a new one...")
            directory_exists(os.path.dirname(path))
            file = open(path, "w")
            file.close()
        return False
    return True

# returns md5 for a Jenkins artifact from its url
def get_md5_jenkins(artifact_url: str) -> str:
    print("Retrieving fingerprint for file verification...")
    subprocess.run(["wget", "--output-document", JENKINS_FINGERPRINT_FILE, artifact_url + JENKINS_FINGERPRINT_SUFFIX])
    if not os.path.isfile(JENKINS_FINGERPRINT_FILE):
        print("ERROR!: The fingerprint from Jenkins could not be retrieved! (" + artifact_url + JENKINS_FINGERPRINT_SUFFIX + ")")
        return ""
    print("Finished retrieving fingerprint!\n")
    
    md5 = ""
    print("Parsing MD5 hash...")
    with open(JENKINS_FINGERPRINT_FILE, "r") as fingerprint:
        for line in fingerprint.readlines():
            if "md5" in line:
                _md5 = line[len("      </h1><div class=\"md5sum\">MD5: "):-len("</div><div>") - 1]
                print("Found MD5 hash (" + _md5 + ")!\n")
                md5 = _md5
    if not md5 == "":
        os.remove(JENKINS_FINGERPRINT_FILE)
        return md5

    os.remove(JENKINS_FINGERPRINT_FILE)
    print("ERROR!: Could not find MD5 hash within the fingerprint retrieved from \"" + artifact_url + JENKINS_FINGERPRINT_SUFFIX + "\"!")
    return ""

# returns true if the md5 hash for local_file matches the md5 hash for the file stored at artifact_url
def check_md5_jenkins(local_file: str, artifact_url: str) -> bool:
    # retrieve md5 hash from server
    md5_remote = get_md5_jenkins(artifact_url)
    if md5_remote == "":
        return False

    # calculate md5 hash of local_file
    print("Calculating MD5 hash of \"" + local_file + "\"...")
    output = subprocess.run(["md5sum", local_file], capture_output = True)
    md5_local = output.stdout.decode("UTF-8")[:MD5_LENGTH]
    print("Finished calculating MD5 hash of \"" + local_file + "\" (" + md5_local + ")!\n")

    # compare the hash retrieved from the server and the hash calculated from local_file
    print("Comparing hashes...")
    if not md5_local == md5_remote:
        print("ERROR!: Hash mismatch! The hash of the local file (MD5: " + md5_local + ") does not match the hash that the remote location is providing (MD5: " + md5_remote + ")!\n")
        return False
    print("Hashes match!\n")
    return True

# starts the server
def run_server(check_for_updates, restart_server_prompt):
    server_running = True
    while server_running:
        os.system("clear")
        
        if check_for_updates:
            # check for last server update (prompt for download if > 30 days)
            pass
            # TODO [low priority]: implement (use update_server())

            # check for last plugin update (prompt for download if > 30 days)
            pass
            # TODO [low priority]: implement (use update_plugins())

        # check server configs for critical mistakes and warn user to fix them
        # TODO [low priority]: implement (use "[M] - Manage Server" function)

        os.system("clear")

        # log start time
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("[START] Starting Spigot server... (" + currenttime + ")\n", RUN_SERVER_LOG_FILE)

        # get the current server executable
        current_spigot_exe = get_current_spigot_exe()
        if current_spigot_exe == "":
            print_and_log("ERROR!: Could not start server because no Spigot server executable could be found.\n", RUN_SERVER_LOG_FILE)
            currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
            print_and_log("[FAIL] Failed to start server! (" + currenttime + ")\n", RUN_SERVER_LOG_FILE)
            input("Press enter to return to the main menu...")
            server_running = False
            break

        # run the server executable
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        # TODO: add options for things like "--nogui"
        print_and_log("Executing \"java -jar " + current_spigot_exe + " --nogui\"... (" + currenttime + ")", RUN_SERVER_LOG_FILE)
        subprocess.run(["java", "-jar", current_spigot_exe, "--nogui"])
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("\"" + current_spigot_exe + "\" has exited. " + currenttime + "\n", RUN_SERVER_LOG_FILE)

        # log stop time
        print_and_log("\n[STOP] The server has stopped.\n", RUN_SERVER_LOG_FILE)

        if restart_server_prompt:
            # prompt user if they would like to restart the server
            response = input("Would you like to restart it? [y/N] > ")
            if not response.lower() == "y":
                server_running = False
                break
        else:
            server_running = False
            break

# installs and updates the base server files
def update_server(clear_on_start: bool, pause_when_done: bool, verify_hash: bool):
    if clear_on_start:
        os.system("clear")
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    file_exists(UPDATE_SERVER_LOG_FILE)
    print_and_log("[START] Starting server update... (" + currenttime + ")\n", UPDATE_SERVER_LOG_FILE)
    
    # download build tools
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("Downloading \"" + BUILD_TOOLS_FILE + "\"... (" + currenttime + ")", UPDATE_SERVER_LOG_FILE)
    print_and_log("Source: \"" + BUILD_TOOLS_REMOTE_LOCATION + "\"", UPDATE_SERVER_LOG_FILE)
    subprocess.run(["wget", "--output-document", BUILD_TOOLS_FILE, BUILD_TOOLS_REMOTE_LOCATION])
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("Finished downloading \"" + BUILD_TOOLS_FILE + "\" from remote location! (" + currenttime + ")\n", UPDATE_SERVER_LOG_FILE)

    # verify hash of build tools
    if verify_hash:
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("Verifying the integrity of the downloaded file... (" + currenttime + ")", UPDATE_SERVER_LOG_FILE)
        if not check_md5_jenkins(BUILD_TOOLS_FILE, BUILD_TOOLS_REMOTE_LOCATION):
            print_and_log("ERROR!: BuildTools failed file verification. This can indicate numerous things, but the most common is an interrupted download.", UPDATE_SERVER_LOG_FILE)
            print_and_log("Give the update a couple more tries. If file verification continues to be problematic, you can update the server without file verification by running `gssm update server --skip-hash`.", UPDATE_SERVER_LOG_FILE)
            print_and_log("Be aware that this will disable file verification, meaning you may be running corrupted and incomplete files.\n", UPDATE_SERVER_LOG_FILE)
            currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
            print_and_log("[FAIL] Failed updating server! (" + currenttime + ")\n", UPDATE_SERVER_LOG_FILE)
            input("Press enter to return to the main menu...")
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("File verification passed! (" + currenttime + ")\n", UPDATE_SERVER_LOG_FILE)
        
    # run/build
    # TODO: add the ability to specify the version of Minecraft the server will be compatible with (e.g. adds "--rev 1.18.2" to the end of the command)
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("Executing \"java -jar ./BuildTools.jar\"... (" + currenttime + ")", UPDATE_SERVER_LOG_FILE)
    print_and_log("See \"" + BUILD_TOOLS_LOG_FILE + "\" for log information about the \"BuildTools.jar\" subprocess.", UPDATE_SERVER_LOG_FILE)
    subprocess.run(["java", "-jar", BUILD_TOOLS_FILE])
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("\"" + BUILD_TOOLS_FILE + "\" has exited. (" + currenttime + ")\n", UPDATE_SERVER_LOG_FILE)
    
    # log time of completion
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("[FINISH] Finished updating server! (" + currenttime + ")\n", UPDATE_SERVER_LOG_FILE)

    if pause_when_done:
        input("Press enter to return to the main menu...")
    
# installs and updates core plugins such as Geyser
# I intend to eventually make a plugin manager that will allow you to add custom sources, so this function can update other plugins as well
def update_plugins(pause_when_done: bool, verify_hash: bool):
    os.system("clear")
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("[START] Starting plugins update... (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)
        
    # check if plugin directory exists; if not, create it
    directory_exists(PLUGIN_DIRECTORY)

    # download geyser
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("Downloading \"" + PLUGIN_DIRECTORY + "/" + GEYSER_FILE + "\"... (" + currenttime + ")", UPDATE_PLUGINS_LOG_FILE)
    print_and_log("Source: \"" + GEYSER_REMOTE_LOCATION + "\"", UPDATE_PLUGINS_LOG_FILE)
    subprocess.run(["wget", "--output-document", PLUGIN_DIRECTORY + "/" + GEYSER_FILE, GEYSER_REMOTE_LOCATION])
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("Finished downloading \"" + PLUGIN_DIRECTORY + "/" + GEYSER_FILE + "\" from remote location! (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)

    # verify hash of geyser
    if verify_hash:
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("Verifying the integrity of \"" + PLUGIN_DIRECTORY + "/" + GEYSER_FILE + "\"... (" + currenttime + ")", UPDATE_PLUGINS_LOG_FILE)
        if not check_md5_jenkins(PLUGIN_DIRECTORY + "/" + GEYSER_FILE, GEYSER_REMOTE_LOCATION):
            print_and_log("ERROR!: Geyser failed file verification. This can indicate numerous things, but the most common is an interrupted download.", UPDATE_PLUGINS_LOG_FILE)
            print_and_log("Give the update a couple more tries. If file verification continues to be problematic, you can update plugins without file verification by running `gssm update plugins --skip-hash`.", UPDATE_PLUGINS_LOG_FILE)
            print_and_log("Be aware that this will disable file verification, meaning you may be running corrupted and incomplete files.\n", UPDATE_PLUGINS_LOG_FILE)
            currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
            print_and_log("[FAIL] Failed updating plugins! (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)
            input("Press enter to return to the main menu...")
            return
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("File verification passed! (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)

    # download floodgate
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("Downloading \"" + PLUGIN_DIRECTORY + "/" + FLOODGATE_FILE + "\"... (" + currenttime + ")", UPDATE_PLUGINS_LOG_FILE)
    print_and_log("Source: \"" + FLOODGATE_REMOTE_LOCATION + "\"", UPDATE_PLUGINS_LOG_FILE)
    subprocess.run(["wget", "--output-document", PLUGIN_DIRECTORY + "/" + FLOODGATE_FILE, FLOODGATE_REMOTE_LOCATION])
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("Finished downloading \"" + PLUGIN_DIRECTORY + "/" + FLOODGATE_FILE + "\" from remote location! (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)
    
    # verify hash of floodgate
    if verify_hash:
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("Verifying the integrity of \"" + PLUGIN_DIRECTORY + "/" + FLOODGATE_FILE + "\"... (" + currenttime + ")", UPDATE_PLUGINS_LOG_FILE)
        if not check_md5_jenkins(PLUGIN_DIRECTORY + "/" + FLOODGATE_FILE, FLOODGATE_REMOTE_LOCATION):
            print_and_log("ERROR!: Floodgate failed file verification. This can indicate numerous things, but the most common is an interrupted download.", UPDATE_PLUGINS_LOG_FILE)
            print_and_log("Give the update a couple more tries. If file verification continues to be problematic, you can update plugins without file verification by running `gssm update plugins --skip-hash`", UPDATE_PLUGINS_LOG_FILE)
            print_and_log("Be aware that this will disable file verification, meaning you may be running corrupted and incomplete files.\n", UPDATE_PLUGINS_LOG_FILE)
            currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
            print_and_log("[FAIL] Failed updating plugins! (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)
            input("Press enter to return to the main menu...")
            return
        currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
        print_and_log("File verification passed! (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)

    # log time of completion
    currenttime = datetime.datetime.now().strftime(DATETIME_FORMAT)
    print_and_log("[FINISH] Finished updating plugins! (" + currenttime + ")\n", UPDATE_PLUGINS_LOG_FILE)

    if (pause_when_done):
        input("Press enter to return to the main menu...")

# show last update times
def show_last_update_times(pause_when_done=True):
    os.system("clear")
    
    last_server_update_time = "No Log Found"

    # fetch last server update time
    if os.path.isfile(UPDATE_SERVER_LOG_FILE):
        with open(UPDATE_SERVER_LOG_FILE, "r") as file:
            lines = file.readlines()
            reversed_lines = [ele for ele in reversed(lines)]
            for line in reversed_lines:
                if "[FAIL]" in line:
                    last_server_update_time = line[line.index("(") + 1:-len(")") - 1] + " [UPDATE FAILED!]"
                    break
                if "[FINISH]" in line:
                    last_server_update_time = line[line.index("(") + 1:-len(")") - 1]
                    break
    else:
        if (VERBOSE):
            print("WARN: There is no logged time for the last update to the server")

    last_plugin_update_time = "No Log Found"

    # fetch last plugin update time
    if os.path.isfile(UPDATE_PLUGINS_LOG_FILE):
        with open(UPDATE_PLUGINS_LOG_FILE, "r") as file:
            lines = file.readlines()
            reversed_lines = [ele for ele in reversed(lines)]
            for line in reversed_lines:
                if "[FAIL]" in line:
                    last_plugin_update_time = line[line.index("(") + 1:-len(")") - 1] + " [UPDATE FAILED!]"
                    break
                if "[FINISH]" in line:
                    last_plugin_update_time = line[line.index("(") + 1:-len(")") - 1]
                    break
    else:
        if VERBOSE:
            print("WARN: There is no logged time for the last update to the plugins")
            
    # print
    print("Last Server Update Time: \'" + last_server_update_time + "\'")
    print("Last Plugin Update Time: \'" + last_plugin_update_time + "\'\n")
            
    if pause_when_done:
        input("Press enter to return to the main menu...")

# check launch arguments
def check_launch_arguments():
    args = sys.argv[1:]

    if len(args) > 0:
        if "-v" in args or "--verbose" in args:
            VERBOSE = True

        if ((args[0] == "-v" or args[0] == "--verbose") and len(args) == 1):
            return

        match args[0]:
            # show how to pass commands directly into GSSM
            case "help":
                print("no.")
                sys.exit()

            # starts the server
            case "run":
                check_for_updates = True
                restart_server_prompt = True

                if len(args) >= 2:
                    check_for_updates = (not "--ignore-updates" in args)
                    restart_server_prompt = (not "--exit-on-stop" in args)

                run_server(check_for_updates, restart_server_prompt)

                sys.exit()

            # update server
            case "update":
                if len(args) >= 2:
                    match args[1]:
                        case "server":
                            # TODO: implement "--skip-hash" when BuildTools provides a remote hash to check
                            # skip_hash = "--skip-hash" in args
                            update_server(False, False, False) # update_server(False, False, not skip_hash)
                        case "plugins":
                            skip_hash = "--skip-hash" in args
                            update_plugins(False, not skip_hash)
                        case "--skip-hash":
                            update_server(False, False, False)
                            update_plugins(False, False)
                        case _:
                            sys.exit("ERROR!: \"" + args[1] + "\" is not a valid update option. Use \"gssm help\" to view how to use the update command properly.")
                else:
                    update_server(False, False, False) # set to (False, False, True) when file verification for server works
                    update_plugins(False, True)

                sys.exit()

            # show last update times
            case "history":
                show_last_update_times(False)
                sys.exit()

            # default or failure to match input
            case _:
                sys.exit("ERROR!: Invalid launch arguments given (" + str(args)[1:-1] + "). Use \"gssm help\" to view available launch arguments.")

# prints message to terminal and logs it in the specified log
def print_and_log(message: str, log: str, new_line_in_file = True):
    with open(log, "a") as file:
        file.write(message + "\n" if new_line_in_file else message)

""" initialize """
# check launch arguments
check_launch_arguments()

# check if GSSM directory exists; if not, create it
directory_exists(GSSM_DIRECTORY)

# start loop for main menu
while main_menu_loop_running:
    os.system("clear")
    # print header
    print("Geyser-Spigot Server Manager (GSSM) by Nicholas Girga\nVersion 1.0\n\nRELEASED UNDER THE MIT LICENSE WITH ABSOLUTELY NO WARRANTY\n")
        
    # print options
    print("What would you like to do?")
    print(" [R] - Run Server")
    #print(" [M] - Manage Server") # TODO [low priority]: implement and nest options for things such as plugins, worlds, players, and settings
    print(" [S] - Update Server") # TODO: merge update functions in update menu. create GSSM self-update function
    print(" [P] - Update Plugins")
    print(" [T] - Show Last Update Time")
    print(" [Q] - Quit")
    
    # ask user for input
    print()
    response = input("> ")
    
    match response.lower():
        # run server
        case "r":
            run_server(True, True)

        # update server
        case "s":
            update_server(True, True, False) # do not verify hash; source does not currently provide fingerprint
            
        # update plugins
        case "p":
            update_plugins(True, True)
            
        # show last update times
        case "t":
            show_last_update_times()
        
        # quit
        case "q":
            os.system("clear")
            main_menu_loop_running = False
        
        # default or failure to match input
        case _:
            os.system("clear")
            print("ERROR!: Invalid option.\n\nSimply type the character found in the square brackets next to the desired function. For example, if I wanted to run \"[T] - Show Last Update Time\", I would simply enter \"t\" and press the enter key.\n")
            input("Press enter to return to the main menu...")
